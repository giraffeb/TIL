[TOC]



#0. 자료구조 - 해싱 

## 1. 소개

* key-value store 방식의 자료구조
* key를 이용해서 값을 읽고 쓰는 방법



## 2. 해싱의 구현

### step1. 리스트(배열)의 index를 key로 이용하기

[예제 리스트(배열)]

|  0   |  1   |  2   |  3   |  4   |  5   |
| :--: | :--: | :--: | :--: | :--: | :--: |
|      |      | 127  |      | 400  | 777  |



* 장점
  * (운좋으면) 자료의 쓰기 연산이 빠르다.
  * 자료의 읽기 연산이 빠르다.
* 단점
  * "자료가 없다"를 표현하는 것이 쉽지않다.
  * 공간이 지나치게 낭비될 수 있다.



### step2. key와 value를 모두 리스트에 저장하기

**key 리스트**

|  0   |  1   |  2   |
| :--: | :--: | :--: |
|  2   |  4   |  5   |

**value 리스트**

|  0   |  1   |  2   |
| :--: | :--: | :--: |
| 127  | 400  | 777  |

* 장점
  * 공간의 낭비가 없다.
  * "자료가 없다"를 표현할 수 있다.
* 단점
  * 자료의 읽기 연산이 풀이1에 비해 느리다.
  * 사실 자료의 쓰기 연산도 풀이 1에 비해 느리다.



###step3. key와 value를 링크드 리스트에 저장

key를 저장하는 링크드 리스트와 value를 저장하는 링크드 리스트 2개가 있을때

삽입, 삭제에 장점을 가지는 링크드 리스트의 장점을 살리지 못한다.

삽입을 위해서는 "자료가 없다"를 확인하기 위해서 키를 모두 검색 후 

순서에 맞게 값을 추가할 때 또 탐색이 또 필요하다.



## 3. 해싱(Hashing)

* (운좋으면) 제한된 공간을 이용하여 자료를 단 한번의 연산으로 찾을 수 있는 방법.
* key를 리스트(배열)의 index로 변환기를 통해 "잘"변환한다. 



### 문제점1 - 여러 key가 하나의 index에 대응된다. (충돌)

* 예를들면,

* 244 -> 변환기() -> 2의 index값 과

* 2 -> 변환기() -> 2의 index 값이 같은 경우

* 이러한 충돌시 값을 읽을때, 저장할때 모두 문제가 발생한다.

  

#### 문제점 1의 해결(읽기, 쓰기)

* key와 value를 함께 저장한다.
* 그래야 진짜 **나의 값** 인지 알 수 있음.
* key가 174 -> 변환기()를 통해 index가 6일때
* value 리스트의 index 6에 (174, 5)으로 key,value를 함께 저장한다.
* index가 동일하게 6이더라도 본래의 key값이 다름을 확인하고 원하는 값이 아님을 판단할 수 있음.



### 해싱은 얼마나 많은 연산을 수행하나?

* **운 좋을 경우**

  * 한 번에 원하는 값을 일고 볼 수 있음
  * `Big-O(1)` 의 시간복잡도를 가짐

* **운 나쁠 경우**

  * 내값을 찾으려 계속해서 배열을 따라가야 함.
  * `Big-O(n)` 의 시간 복잡도를 가짐.

* **운이 나쁘지 않으려면?**

  * 변환기를 굉장히 잘 만들어야 함.

* **하지만 완벽한 변환기는 없다.**

  * 변환기의 원리를 알면, 항상 최악의 경우를 만들어 낼 수 있음.

* **그러나 운이 엄청 나쁜 경우는 잘 없어서, 매우 많이 쓰임.**

  * 일부러 같은 칸에 계속 집어 넣기도 힘들다.

  

